{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { latLng, map, control, tileLayer } from 'leaflet';\n\nclass LeafletUtil {\n  static mapToArray(map) {\n    const toReturn = [];\n\n    for (const k in map) {\n      if (map.hasOwnProperty(k)) {\n        toReturn.push(map[k]);\n      }\n    }\n\n    return toReturn;\n  }\n\n  static handleEvent(zone, eventEmitter, event) {\n    // Don't want to emit if there are no observers\n    if (0 < eventEmitter.observers.length) {\n      zone.run(() => {\n        eventEmitter.emit(event);\n      });\n    }\n  }\n\n}\n\nclass LeafletDirective {\n  constructor(element, zone) {\n    this.element = element;\n    this.zone = zone;\n    this.DEFAULT_ZOOM = 1;\n    this.DEFAULT_CENTER = latLng(38.907192, -77.036871);\n    this.DEFAULT_FPZ_OPTIONS = {};\n    this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS; // Default configuration\n\n    this.options = {}; // Configure callback function for the map\n\n    this.mapReady = new EventEmitter();\n    this.zoomChange = new EventEmitter();\n    this.centerChange = new EventEmitter(); // Mouse Map Events\n\n    this.onClick = new EventEmitter();\n    this.onDoubleClick = new EventEmitter();\n    this.onMouseDown = new EventEmitter();\n    this.onMouseUp = new EventEmitter();\n    this.onMouseMove = new EventEmitter();\n    this.onMouseOver = new EventEmitter();\n    this.onMouseOut = new EventEmitter(); // Map Move Events\n\n    this.onMapMove = new EventEmitter();\n    this.onMapMoveStart = new EventEmitter();\n    this.onMapMoveEnd = new EventEmitter(); // Map Zoom Events\n\n    this.onMapZoom = new EventEmitter();\n    this.onMapZoomStart = new EventEmitter();\n    this.onMapZoomEnd = new EventEmitter(); // Nothing here\n  }\n\n  ngOnInit() {\n    // Create the map outside of angular so the various map events don't trigger change detection\n    this.zone.runOutsideAngular(() => {\n      // Create the map with some reasonable defaults\n      this.map = map(this.element.nativeElement, this.options);\n      this.addMapEventListeners();\n    }); // Only setView if there is a center/zoom\n\n    if (null != this.center && null != this.zoom) {\n      this.setView(this.center, this.zoom);\n    } // Set up all the initial settings\n\n\n    if (null != this.fitBounds) {\n      this.setFitBounds(this.fitBounds);\n    }\n\n    if (null != this.maxBounds) {\n      this.setMaxBounds(this.maxBounds);\n    }\n\n    if (null != this.minZoom) {\n      this.setMinZoom(this.minZoom);\n    }\n\n    if (null != this.maxZoom) {\n      this.setMaxZoom(this.maxZoom);\n    }\n\n    this.doResize(); // Fire map ready event\n\n    this.mapReady.emit(this.map);\n  }\n\n  ngOnChanges(changes) {\n    /*\n     * The following code is to address an issue with our (basic) implementation of\n     * zooming and panning. From our testing, it seems that a pan operation followed\n     * by a zoom operation in the same thread will interfere with eachother. The zoom\n     * operation interrupts/cancels the pan, resulting in a final center point that is\n     * inaccurate. The solution seems to be to either separate them with a timeout or\n      * to collapse them into a setView call.\n     */\n    // Zooming and Panning\n    if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n      this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n    } // Set the zoom level\n    else if (changes['zoom']) {\n      this.setZoom(changes['zoom'].currentValue);\n    } // Set the map center\n    else if (changes['center']) {\n      this.setCenter(changes['center'].currentValue);\n    } // Other options\n\n\n    if (changes['fitBounds']) {\n      this.setFitBounds(changes['fitBounds'].currentValue);\n    }\n\n    if (changes['maxBounds']) {\n      this.setMaxBounds(changes['maxBounds'].currentValue);\n    }\n\n    if (changes['minZoom']) {\n      this.setMinZoom(changes['minZoom'].currentValue);\n    }\n\n    if (changes['maxZoom']) {\n      this.setMaxZoom(changes['maxZoom'].currentValue);\n    }\n  }\n\n  ngOnDestroy() {\n    // If this directive is destroyed, the map is too\n    if (null != this.map) {\n      this.map.remove();\n    }\n  }\n\n  getMap() {\n    return this.map;\n  }\n\n  onResize() {\n    this.delayResize();\n  }\n\n  addMapEventListeners() {\n    const registerEventHandler = (eventName, handler) => {\n      this.map.on(eventName, handler);\n    }; // Add all the pass-through mouse event handlers\n\n\n    registerEventHandler('click', e => LeafletUtil.handleEvent(this.zone, this.onClick, e));\n    registerEventHandler('dblclick', e => LeafletUtil.handleEvent(this.zone, this.onDoubleClick, e));\n    registerEventHandler('mousedown', e => LeafletUtil.handleEvent(this.zone, this.onMouseDown, e));\n    registerEventHandler('mouseup', e => LeafletUtil.handleEvent(this.zone, this.onMouseUp, e));\n    registerEventHandler('mouseover', e => LeafletUtil.handleEvent(this.zone, this.onMouseOver, e));\n    registerEventHandler('mouseout', e => LeafletUtil.handleEvent(this.zone, this.onMouseOut, e));\n    registerEventHandler('mousemove', e => LeafletUtil.handleEvent(this.zone, this.onMouseMove, e));\n    registerEventHandler('zoomstart', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomStart, e));\n    registerEventHandler('zoom', e => LeafletUtil.handleEvent(this.zone, this.onMapZoom, e));\n    registerEventHandler('zoomend', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomEnd, e));\n    registerEventHandler('movestart', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveStart, e));\n    registerEventHandler('move', e => LeafletUtil.handleEvent(this.zone, this.onMapMove, e));\n    registerEventHandler('moveend', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveEnd, e)); // Update any things for which we provide output bindings\n\n    const outputUpdateHandler = () => {\n      const zoom = this.map.getZoom();\n\n      if (zoom !== this.zoom) {\n        this.zoom = zoom;\n        LeafletUtil.handleEvent(this.zone, this.zoomChange, zoom);\n      }\n\n      const center = this.map.getCenter();\n\n      if (null != center || null != this.center) {\n        if ((null == center || null == this.center) && center !== this.center || center.lat !== this.center.lat || center.lng !== this.center.lng) {\n          this.center = center;\n          LeafletUtil.handleEvent(this.zone, this.centerChange, center);\n        }\n      }\n    };\n\n    registerEventHandler('moveend', outputUpdateHandler);\n    registerEventHandler('zoomend', outputUpdateHandler);\n  }\n  /**\n   * Resize the map to fit it's parent container\n   */\n\n\n  doResize() {\n    // Run this outside of angular so the map events stay outside of angular\n    this.zone.runOutsideAngular(() => {\n      // Invalidate the map size to trigger it to update itself\n      if (null != this.map) {\n        this.map.invalidateSize({});\n      }\n    });\n  }\n  /**\n   * Manage a delayed resize of the component\n   */\n\n\n  delayResize() {\n    if (null != this.resizeTimer) {\n      clearTimeout(this.resizeTimer);\n    }\n\n    this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n  }\n  /**\n   * Set the view (center/zoom) all at once\n   * @param center The new center\n   * @param zoom The new zoom level\n   */\n\n\n  setView(center, zoom) {\n    if (null != this.map && null != center && null != zoom) {\n      this.map.setView(center, zoom, this.zoomPanOptions);\n    }\n  }\n  /**\n   * Set the map zoom level\n   * @param zoom the new zoom level for the map\n   */\n\n\n  setZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setZoom(zoom, this.zoomOptions);\n    }\n  }\n  /**\n   * Set the center of the map\n   * @param center the center point\n   */\n\n\n  setCenter(center) {\n    if (null != this.map && null != center) {\n      this.map.panTo(center, this.panOptions);\n    }\n  }\n  /**\n   * Fit the map to the bounds\n   * @param latLngBounds the boundary to set\n   */\n\n\n  setFitBounds(latLngBounds) {\n    if (null != this.map && null != latLngBounds) {\n      this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n    }\n  }\n  /**\n   * Set the map's max bounds\n   * @param latLngBounds the boundary to set\n   */\n\n\n  setMaxBounds(latLngBounds) {\n    if (null != this.map && null != latLngBounds) {\n      this.map.setMaxBounds(latLngBounds);\n    }\n  }\n  /**\n   * Set the map's min zoom\n   * @param number the new min zoom\n   */\n\n\n  setMinZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setMinZoom(zoom);\n    }\n  }\n  /**\n   * Set the map's min zoom\n   * @param number the new min zoom\n   */\n\n\n  setMaxZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setMaxZoom(zoom);\n    }\n  }\n\n}\n\nLeafletDirective.ɵfac = function LeafletDirective_Factory(t) {\n  return new (t || LeafletDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletDirective,\n  selectors: [[\"\", \"leaflet\", \"\"]],\n  hostBindings: function LeafletDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"resize\", function LeafletDirective_resize_HostBindingHandler() {\n        return ctx.onResize();\n      }, false, i0.ɵɵresolveWindow);\n    }\n  },\n  inputs: {\n    fitBoundsOptions: [\"leafletFitBoundsOptions\", \"fitBoundsOptions\"],\n    panOptions: [\"leafletPanOptions\", \"panOptions\"],\n    zoomOptions: [\"leafletZoomOptions\", \"zoomOptions\"],\n    zoomPanOptions: [\"leafletZoomPanOptions\", \"zoomPanOptions\"],\n    options: [\"leafletOptions\", \"options\"],\n    zoom: [\"leafletZoom\", \"zoom\"],\n    center: [\"leafletCenter\", \"center\"],\n    fitBounds: [\"leafletFitBounds\", \"fitBounds\"],\n    maxBounds: [\"leafletMaxBounds\", \"maxBounds\"],\n    minZoom: [\"leafletMinZoom\", \"minZoom\"],\n    maxZoom: [\"leafletMaxZoom\", \"maxZoom\"]\n  },\n  outputs: {\n    mapReady: \"leafletMapReady\",\n    zoomChange: \"leafletZoomChange\",\n    centerChange: \"leafletCenterChange\",\n    onClick: \"leafletClick\",\n    onDoubleClick: \"leafletDoubleClick\",\n    onMouseDown: \"leafletMouseDown\",\n    onMouseUp: \"leafletMouseUp\",\n    onMouseMove: \"leafletMouseMove\",\n    onMouseOver: \"leafletMouseOver\",\n    onMouseOut: \"leafletMouseOut\",\n    onMapMove: \"leafletMapMove\",\n    onMapMoveStart: \"leafletMapMoveStart\",\n    onMapMoveEnd: \"leafletMapMoveEnd\",\n    onMapZoom: \"leafletMapZoom\",\n    onMapZoomStart: \"leafletMapZoomStart\",\n    onMapZoomEnd: \"leafletMapZoomEnd\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leaflet]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    fitBoundsOptions: [{\n      type: Input,\n      args: ['leafletFitBoundsOptions']\n    }],\n    panOptions: [{\n      type: Input,\n      args: ['leafletPanOptions']\n    }],\n    zoomOptions: [{\n      type: Input,\n      args: ['leafletZoomOptions']\n    }],\n    zoomPanOptions: [{\n      type: Input,\n      args: ['leafletZoomPanOptions']\n    }],\n    options: [{\n      type: Input,\n      args: ['leafletOptions']\n    }],\n    mapReady: [{\n      type: Output,\n      args: ['leafletMapReady']\n    }],\n    zoom: [{\n      type: Input,\n      args: ['leafletZoom']\n    }],\n    zoomChange: [{\n      type: Output,\n      args: ['leafletZoomChange']\n    }],\n    center: [{\n      type: Input,\n      args: ['leafletCenter']\n    }],\n    centerChange: [{\n      type: Output,\n      args: ['leafletCenterChange']\n    }],\n    fitBounds: [{\n      type: Input,\n      args: ['leafletFitBounds']\n    }],\n    maxBounds: [{\n      type: Input,\n      args: ['leafletMaxBounds']\n    }],\n    minZoom: [{\n      type: Input,\n      args: ['leafletMinZoom']\n    }],\n    maxZoom: [{\n      type: Input,\n      args: ['leafletMaxZoom']\n    }],\n    onClick: [{\n      type: Output,\n      args: ['leafletClick']\n    }],\n    onDoubleClick: [{\n      type: Output,\n      args: ['leafletDoubleClick']\n    }],\n    onMouseDown: [{\n      type: Output,\n      args: ['leafletMouseDown']\n    }],\n    onMouseUp: [{\n      type: Output,\n      args: ['leafletMouseUp']\n    }],\n    onMouseMove: [{\n      type: Output,\n      args: ['leafletMouseMove']\n    }],\n    onMouseOver: [{\n      type: Output,\n      args: ['leafletMouseOver']\n    }],\n    onMouseOut: [{\n      type: Output,\n      args: ['leafletMouseOut']\n    }],\n    onMapMove: [{\n      type: Output,\n      args: ['leafletMapMove']\n    }],\n    onMapMoveStart: [{\n      type: Output,\n      args: ['leafletMapMoveStart']\n    }],\n    onMapMoveEnd: [{\n      type: Output,\n      args: ['leafletMapMoveEnd']\n    }],\n    onMapZoom: [{\n      type: Output,\n      args: ['leafletMapZoom']\n    }],\n    onMapZoomStart: [{\n      type: Output,\n      args: ['leafletMapZoomStart']\n    }],\n    onMapZoomEnd: [{\n      type: Output,\n      args: ['leafletMapZoomEnd']\n    }],\n    onResize: [{\n      type: HostListener,\n      args: ['window:resize', []]\n    }]\n  });\n})();\n\nclass LeafletDirectiveWrapper {\n  constructor(leafletDirective) {\n    this.leafletDirective = leafletDirective;\n  }\n\n  init() {// Nothing for now\n  }\n\n  getMap() {\n    return this.leafletDirective.getMap();\n  }\n\n}\n/**\n * Layer directive\n *\n * This directive is used to directly control a single map layer. The purpose of this directive is to\n * be used as part of a child structural directive of the map element.\n *\n */\n\n\nclass LeafletLayerDirective {\n  constructor(leafletDirective, zone) {\n    this.zone = zone; // Layer Events\n\n    this.onAdd = new EventEmitter();\n    this.onRemove = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n  }\n\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n  }\n\n  ngOnDestroy() {\n    if (null != this.layer) {\n      // Unregister the event handlers\n      this.removeLayerEventListeners(this.layer); // Remove the layer from the map\n\n      this.layer.remove();\n    }\n  }\n\n  ngOnChanges(changes) {\n    if (changes['layer']) {\n      // Update the layer\n      const p = changes['layer'].previousValue;\n      const n = changes['layer'].currentValue;\n      this.zone.runOutsideAngular(() => {\n        if (null != p) {\n          this.removeLayerEventListeners(p);\n          p.remove();\n        }\n\n        if (null != n) {\n          this.addLayerEventListeners(n);\n          this.leafletDirective.getMap().addLayer(n);\n        }\n      });\n    }\n  }\n\n  addLayerEventListeners(l) {\n    this.onAddLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onAdd, e);\n\n    l.on('add', this.onAddLayerHandler);\n\n    this.onRemoveLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onRemove, e);\n\n    l.on('remove', this.onRemoveLayerHandler);\n  }\n\n  removeLayerEventListeners(l) {\n    l.off('add', this.onAddLayerHandler);\n    l.off('remove', this.onRemoveLayerHandler);\n  }\n\n}\n\nLeafletLayerDirective.ɵfac = function LeafletLayerDirective_Factory(t) {\n  return new (t || LeafletLayerDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletLayerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletLayerDirective,\n  selectors: [[\"\", \"leafletLayer\", \"\"]],\n  inputs: {\n    layer: [\"leafletLayer\", \"layer\"]\n  },\n  outputs: {\n    onAdd: \"leafletLayerAdd\",\n    onRemove: \"leafletLayerRemove\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayer]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    layer: [{\n      type: Input,\n      args: ['leafletLayer']\n    }],\n    onAdd: [{\n      type: Output,\n      args: ['leafletLayerAdd']\n    }],\n    onRemove: [{\n      type: Output,\n      args: ['leafletLayerRemove']\n    }]\n  });\n})();\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\n\n\nclass LeafletLayersDirective {\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.layersDiffer = this.differs.find([]).create();\n  } // Set/get the layers\n\n\n  set layers(v) {\n    this.layersValue = v; // Now that we have a differ, do an immediate layer update\n\n    this.updateLayers();\n  }\n\n  get layers() {\n    return this.layersValue;\n  }\n\n  ngDoCheck() {\n    this.updateLayers();\n  }\n\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init(); // Update layers once the map is ready\n\n    this.updateLayers();\n  }\n\n  ngOnDestroy() {\n    this.layers = [];\n  }\n  /**\n   * Update the state of the layers.\n   * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n   * This is important because it allows us to react to changes to the contents of the array as well\n   * as changes to the actual array instance.\n   */\n\n\n  updateLayers() {\n    const map = this.leafletDirective.getMap();\n\n    if (null != map && null != this.layersDiffer) {\n      const changes = this.layersDiffer.diff(this.layersValue);\n\n      if (null != changes) {\n        // Run outside angular to ensure layer events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n          changes.forEachRemovedItem(c => {\n            map.removeLayer(c.item);\n          });\n          changes.forEachAddedItem(c => {\n            map.addLayer(c.item);\n          });\n        });\n      }\n    }\n  }\n\n}\n\nLeafletLayersDirective.ɵfac = function LeafletLayersDirective_Factory(t) {\n  return new (t || LeafletLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletLayersDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletLayersDirective,\n  selectors: [[\"\", \"leafletLayers\", \"\"]],\n  inputs: {\n    layers: [\"leafletLayers\", \"layers\"]\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayersDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayers]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.IterableDiffers\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    layers: [{\n      type: Input,\n      args: ['leafletLayers']\n    }]\n  });\n})();\n\nclass LeafletControlLayersChanges {\n  constructor() {\n    this.layersRemoved = 0;\n    this.layersChanged = 0;\n    this.layersAdded = 0;\n  }\n\n  changed() {\n    return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n  }\n\n}\n\nclass LeafletControlLayersWrapper {\n  constructor(zone, layersControlReady) {\n    this.zone = zone;\n    this.layersControlReady = layersControlReady;\n  }\n\n  getLayersControl() {\n    return this.layersControl;\n  }\n\n  init(controlConfig, controlOptions) {\n    const baseLayers = controlConfig.baseLayers || {};\n    const overlays = controlConfig.overlays || {}; // Create the control outside of angular to ensure events don't trigger change detection\n\n    this.zone.runOutsideAngular(() => {\n      this.layersControl = control.layers(baseLayers, overlays, controlOptions);\n    });\n    this.layersControlReady.emit(this.layersControl);\n    return this.layersControl;\n  }\n\n  applyBaseLayerChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n    }\n\n    return results;\n  }\n\n  applyOverlayChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addOverlay);\n    }\n\n    return results;\n  }\n\n  applyChanges(changes, addFn) {\n    const results = new LeafletControlLayersChanges();\n\n    if (null != changes) {\n      // All layer management is outside angular to avoid layer events from triggering change detection\n      this.zone.runOutsideAngular(() => {\n        changes.forEachChangedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersChanged++;\n        });\n        changes.forEachRemovedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          results.layersRemoved++;\n        });\n        changes.forEachAddedItem(c => {\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersAdded++;\n        });\n      });\n    }\n\n    return results;\n  }\n\n}\n\nclass LeafletControlLayersConfig {\n  constructor() {\n    this.baseLayers = {};\n    this.overlays = {};\n  }\n\n}\n/**\n * Layers Control\n *\n * This directive is used to configure the layers control. The input accepts an object with two\n * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the last one it sees will be used.\n */\n\n\nclass LeafletLayersControlDirective {\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.layersControlReady = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady); // Generate differs\n\n    this.baseLayersDiffer = this.differs.find({}).create();\n    this.overlaysDiffer = this.differs.find({}).create();\n  }\n\n  set layersControlConfig(v) {\n    // Validation/init stuff\n    if (null == v) {\n      v = new LeafletControlLayersConfig();\n    }\n\n    if (null == v.baseLayers) {\n      v.baseLayers = {};\n    }\n\n    if (null == v.overlays) {\n      v.overlays = {};\n    } // Store the value\n\n\n    this.layersControlConfigValue = v; // Update the map\n\n    this.updateLayers();\n  }\n\n  get layersControlConfig() {\n    return this.layersControlConfigValue;\n  }\n\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init(); // Set up control outside of angular to avoid change detection when using the control\n\n    this.zone.runOutsideAngular(() => {\n      // Set up all the initial settings\n      this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n    });\n    this.updateLayers();\n  }\n\n  ngOnDestroy() {\n    this.layersControlConfig = {\n      baseLayers: {},\n      overlays: {}\n    };\n    this.controlLayers.getLayersControl().remove();\n  }\n\n  ngDoCheck() {\n    this.updateLayers();\n  }\n\n  updateLayers() {\n    const map = this.leafletDirective.getMap();\n    const layersControl = this.controlLayers.getLayersControl();\n\n    if (null != map && null != layersControl) {\n      // Run the baselayers differ\n      if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n        const changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n        this.controlLayers.applyBaseLayerChanges(changes);\n      } // Run the overlays differ\n\n\n      if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n        const changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n        this.controlLayers.applyOverlayChanges(changes);\n      }\n    }\n  }\n\n}\n\nLeafletLayersControlDirective.ɵfac = function LeafletLayersControlDirective_Factory(t) {\n  return new (t || LeafletLayersControlDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletLayersControlDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletLayersControlDirective,\n  selectors: [[\"\", \"leafletLayersControl\", \"\"]],\n  inputs: {\n    layersControlConfig: [\"leafletLayersControl\", \"layersControlConfig\"],\n    layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"]\n  },\n  outputs: {\n    layersControlReady: \"leafletLayersControlReady\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayersControlDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayersControl]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.KeyValueDiffers\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    layersControlConfig: [{\n      type: Input,\n      args: ['leafletLayersControl']\n    }],\n    layersControlOptions: [{\n      type: Input,\n      args: ['leafletLayersControlOptions']\n    }],\n    layersControlReady: [{\n      type: Output,\n      args: ['leafletLayersControlReady']\n    }]\n  });\n})();\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\n\n\nclass LeafletBaseLayersDirective {\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone; // Output for once the layers control is ready\n\n    this.layersControlReady = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n    this.baseLayersDiffer = this.differs.find({}).create();\n  } // Set/get baseLayers\n\n\n  set baseLayers(v) {\n    this.baseLayersValue = v;\n    this.updateBaseLayers();\n  }\n\n  get baseLayers() {\n    return this.baseLayersValue;\n  }\n\n  ngOnDestroy() {\n    this.baseLayers = {};\n\n    if (null != this.controlLayers.getLayersControl()) {\n      this.controlLayers.getLayersControl().remove();\n    }\n  }\n\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init(); // Create the control outside angular to prevent events from triggering chnage detection\n\n    this.zone.runOutsideAngular(() => {\n      // Initially configure the controlLayers\n      this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n    });\n    this.updateBaseLayers();\n  }\n\n  ngDoCheck() {\n    this.updateBaseLayers();\n  }\n\n  updateBaseLayers() {\n    const map = this.leafletDirective.getMap();\n    const layersControl = this.controlLayers.getLayersControl();\n\n    if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n      const changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n      const results = this.controlLayers.applyBaseLayerChanges(changes);\n\n      if (results.changed()) {\n        this.syncBaseLayer();\n      }\n    }\n  }\n  /**\n   * Check the current base layer and change it to the new one if necessary\n   */\n\n\n  syncBaseLayer() {\n    const map = this.leafletDirective.getMap();\n    const layers = LeafletUtil.mapToArray(this.baseLayers);\n    let foundLayer; // Search all the layers in the map to see if we can find them in the baselayer array\n\n    map.eachLayer(l => {\n      foundLayer = layers.find(bl => l === bl);\n    }); // Did we find the layer?\n\n    if (null != foundLayer) {\n      // Yes - set the baselayer to the one we found\n      this.baseLayer = foundLayer;\n    } else {\n      // No - set the baselayer to the first in the array and add it to the map\n      if (layers.length > 0) {\n        this.baseLayer = layers[0]; // Add layers outside of angular to prevent events from triggering change detection\n\n        this.zone.runOutsideAngular(() => {\n          this.baseLayer.addTo(map);\n        });\n      }\n    }\n  }\n\n}\n\nLeafletBaseLayersDirective.ɵfac = function LeafletBaseLayersDirective_Factory(t) {\n  return new (t || LeafletBaseLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletBaseLayersDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletBaseLayersDirective,\n  selectors: [[\"\", \"leafletBaseLayers\", \"\"]],\n  inputs: {\n    baseLayers: [\"leafletBaseLayers\", \"baseLayers\"],\n    layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"]\n  },\n  outputs: {\n    layersControlReady: \"leafletLayersControlReady\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletBaseLayersDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletBaseLayers]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.KeyValueDiffers\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    baseLayers: [{\n      type: Input,\n      args: ['leafletBaseLayers']\n    }],\n    layersControlOptions: [{\n      type: Input,\n      args: ['leafletLayersControlOptions']\n    }],\n    layersControlReady: [{\n      type: Output,\n      args: ['leafletLayersControlReady']\n    }]\n  });\n})();\n\nclass LeafletModule {}\n\nLeafletModule.ɵfac = function LeafletModule_Factory(t) {\n  return new (t || LeafletModule)();\n};\n\nLeafletModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LeafletModule\n});\nLeafletModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletModule, [{\n    type: NgModule,\n    args: [{\n      exports: [LeafletDirective, LeafletLayerDirective, LeafletLayersDirective, LeafletLayersControlDirective, LeafletBaseLayersDirective],\n      declarations: [LeafletDirective, LeafletLayerDirective, LeafletLayersDirective, LeafletLayersControlDirective, LeafletBaseLayersDirective]\n    }]\n  }], null, null);\n})();\n\nclass LeafletTileLayerDefinition {\n  constructor(type, url, options) {\n    this.type = type;\n    this.url = url;\n    this.options = options;\n  }\n  /**\n   * Creates a TileLayer from the provided definition. This is a convenience function\n   * to help with generating layers from objects.\n   *\n   * @param layerDef The layer to create\n   * @returns {TileLayer} The TileLayer that has been created\n   */\n\n\n  static createTileLayer(layerDef) {\n    let layer;\n\n    switch (layerDef.type) {\n      case 'xyz':\n        layer = tileLayer(layerDef.url, layerDef.options);\n        break;\n\n      case 'wms':\n      default:\n        layer = tileLayer.wms(layerDef.url, layerDef.options);\n        break;\n    }\n\n    return layer;\n  }\n  /**\n   * Creates a TileLayer for each key in the incoming map. This is a convenience function\n   * for generating an associative array of layers from an associative array of objects\n   *\n   * @param layerDefs A map of key to tile layer definition\n   * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n   */\n\n\n  static createTileLayers(layerDefs) {\n    const layers = {};\n\n    for (const k in layerDefs) {\n      if (layerDefs.hasOwnProperty(k)) {\n        layers[k] = LeafletTileLayerDefinition.createTileLayer(layerDefs[k]);\n      }\n    }\n\n    return layers;\n  }\n  /**\n   * Create a Tile Layer from the current state of this object\n   *\n   * @returns {TileLayer} A new TileLayer\n   */\n\n\n  createTileLayer() {\n    return LeafletTileLayerDefinition.createTileLayer(this);\n  }\n\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LeafletBaseLayersDirective, LeafletControlLayersChanges, LeafletControlLayersConfig, LeafletControlLayersWrapper, LeafletDirective, LeafletDirectiveWrapper, LeafletLayerDirective, LeafletLayersControlDirective, LeafletLayersDirective, LeafletModule, LeafletTileLayerDefinition, LeafletUtil }; //# sourceMappingURL=asymmetrik-ngx-leaflet.mjs.map","map":{"version":3,"names":["i0","EventEmitter","Directive","Input","Output","HostListener","NgModule","latLng","map","control","tileLayer","LeafletUtil","mapToArray","toReturn","k","hasOwnProperty","push","handleEvent","zone","eventEmitter","event","observers","length","run","emit","LeafletDirective","constructor","element","DEFAULT_ZOOM","DEFAULT_CENTER","DEFAULT_FPZ_OPTIONS","fitBoundsOptions","panOptions","zoomOptions","zoomPanOptions","options","mapReady","zoomChange","centerChange","onClick","onDoubleClick","onMouseDown","onMouseUp","onMouseMove","onMouseOver","onMouseOut","onMapMove","onMapMoveStart","onMapMoveEnd","onMapZoom","onMapZoomStart","onMapZoomEnd","ngOnInit","runOutsideAngular","nativeElement","addMapEventListeners","center","zoom","setView","fitBounds","setFitBounds","maxBounds","setMaxBounds","minZoom","setMinZoom","maxZoom","setMaxZoom","doResize","ngOnChanges","changes","currentValue","setZoom","setCenter","ngOnDestroy","remove","getMap","onResize","delayResize","registerEventHandler","eventName","handler","on","e","outputUpdateHandler","getZoom","getCenter","lat","lng","invalidateSize","resizeTimer","clearTimeout","setTimeout","bind","panTo","latLngBounds","ɵfac","ElementRef","NgZone","ɵdir","type","args","selector","LeafletDirectiveWrapper","leafletDirective","init","LeafletLayerDirective","onAdd","onRemove","layer","removeLayerEventListeners","p","previousValue","n","addLayerEventListeners","addLayer","l","onAddLayerHandler","onRemoveLayerHandler","off","LeafletLayersDirective","differs","layersDiffer","find","create","layers","v","layersValue","updateLayers","ngDoCheck","diff","forEachRemovedItem","c","removeLayer","item","forEachAddedItem","IterableDiffers","LeafletControlLayersChanges","layersRemoved","layersChanged","layersAdded","changed","LeafletControlLayersWrapper","layersControlReady","getLayersControl","layersControl","controlConfig","controlOptions","baseLayers","overlays","applyBaseLayerChanges","results","applyChanges","addBaseLayer","applyOverlayChanges","addOverlay","addFn","forEachChangedItem","call","key","LeafletControlLayersConfig","LeafletLayersControlDirective","controlLayers","baseLayersDiffer","overlaysDiffer","layersControlConfig","layersControlConfigValue","layersControlOptions","addTo","KeyValueDiffers","LeafletBaseLayersDirective","baseLayersValue","updateBaseLayers","syncBaseLayer","foundLayer","eachLayer","bl","baseLayer","LeafletModule","ɵmod","ɵinj","exports","declarations","LeafletTileLayerDefinition","url","createTileLayer","layerDef","wms","createTileLayers","layerDefs"],"sources":["C:/Users/victo/OneDrive/Escritorio/TFG/TFG-Código/Frontend/node_modules/@asymmetrik/ngx-leaflet/fesm2020/asymmetrik-ngx-leaflet.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { latLng, map, control, tileLayer } from 'leaflet';\n\nclass LeafletUtil {\n    static mapToArray(map) {\n        const toReturn = [];\n        for (const k in map) {\n            if (map.hasOwnProperty(k)) {\n                toReturn.push(map[k]);\n            }\n        }\n        return toReturn;\n    }\n    static handleEvent(zone, eventEmitter, event) {\n        // Don't want to emit if there are no observers\n        if (0 < eventEmitter.observers.length) {\n            zone.run(() => {\n                eventEmitter.emit(event);\n            });\n        }\n    }\n}\n\nclass LeafletDirective {\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.DEFAULT_ZOOM = 1;\n        this.DEFAULT_CENTER = latLng(38.907192, -77.036871);\n        this.DEFAULT_FPZ_OPTIONS = {};\n        this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS;\n        // Default configuration\n        this.options = {};\n        // Configure callback function for the map\n        this.mapReady = new EventEmitter();\n        this.zoomChange = new EventEmitter();\n        this.centerChange = new EventEmitter();\n        // Mouse Map Events\n        this.onClick = new EventEmitter();\n        this.onDoubleClick = new EventEmitter();\n        this.onMouseDown = new EventEmitter();\n        this.onMouseUp = new EventEmitter();\n        this.onMouseMove = new EventEmitter();\n        this.onMouseOver = new EventEmitter();\n        this.onMouseOut = new EventEmitter();\n        // Map Move Events\n        this.onMapMove = new EventEmitter();\n        this.onMapMoveStart = new EventEmitter();\n        this.onMapMoveEnd = new EventEmitter();\n        // Map Zoom Events\n        this.onMapZoom = new EventEmitter();\n        this.onMapZoomStart = new EventEmitter();\n        this.onMapZoomEnd = new EventEmitter();\n        // Nothing here\n    }\n    ngOnInit() {\n        // Create the map outside of angular so the various map events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n            // Create the map with some reasonable defaults\n            this.map = map(this.element.nativeElement, this.options);\n            this.addMapEventListeners();\n        });\n        // Only setView if there is a center/zoom\n        if (null != this.center && null != this.zoom) {\n            this.setView(this.center, this.zoom);\n        }\n        // Set up all the initial settings\n        if (null != this.fitBounds) {\n            this.setFitBounds(this.fitBounds);\n        }\n        if (null != this.maxBounds) {\n            this.setMaxBounds(this.maxBounds);\n        }\n        if (null != this.minZoom) {\n            this.setMinZoom(this.minZoom);\n        }\n        if (null != this.maxZoom) {\n            this.setMaxZoom(this.maxZoom);\n        }\n        this.doResize();\n        // Fire map ready event\n        this.mapReady.emit(this.map);\n    }\n    ngOnChanges(changes) {\n        /*\n         * The following code is to address an issue with our (basic) implementation of\n         * zooming and panning. From our testing, it seems that a pan operation followed\n         * by a zoom operation in the same thread will interfere with eachother. The zoom\n         * operation interrupts/cancels the pan, resulting in a final center point that is\n         * inaccurate. The solution seems to be to either separate them with a timeout or\n          * to collapse them into a setView call.\n         */\n        // Zooming and Panning\n        if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n            this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n        }\n        // Set the zoom level\n        else if (changes['zoom']) {\n            this.setZoom(changes['zoom'].currentValue);\n        }\n        // Set the map center\n        else if (changes['center']) {\n            this.setCenter(changes['center'].currentValue);\n        }\n        // Other options\n        if (changes['fitBounds']) {\n            this.setFitBounds(changes['fitBounds'].currentValue);\n        }\n        if (changes['maxBounds']) {\n            this.setMaxBounds(changes['maxBounds'].currentValue);\n        }\n        if (changes['minZoom']) {\n            this.setMinZoom(changes['minZoom'].currentValue);\n        }\n        if (changes['maxZoom']) {\n            this.setMaxZoom(changes['maxZoom'].currentValue);\n        }\n    }\n    ngOnDestroy() {\n        // If this directive is destroyed, the map is too\n        if (null != this.map) {\n            this.map.remove();\n        }\n    }\n    getMap() {\n        return this.map;\n    }\n    onResize() {\n        this.delayResize();\n    }\n    addMapEventListeners() {\n        const registerEventHandler = (eventName, handler) => {\n            this.map.on(eventName, handler);\n        };\n        // Add all the pass-through mouse event handlers\n        registerEventHandler('click', (e) => LeafletUtil.handleEvent(this.zone, this.onClick, e));\n        registerEventHandler('dblclick', (e) => LeafletUtil.handleEvent(this.zone, this.onDoubleClick, e));\n        registerEventHandler('mousedown', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseDown, e));\n        registerEventHandler('mouseup', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseUp, e));\n        registerEventHandler('mouseover', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseOver, e));\n        registerEventHandler('mouseout', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseOut, e));\n        registerEventHandler('mousemove', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseMove, e));\n        registerEventHandler('zoomstart', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoomStart, e));\n        registerEventHandler('zoom', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoom, e));\n        registerEventHandler('zoomend', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoomEnd, e));\n        registerEventHandler('movestart', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMoveStart, e));\n        registerEventHandler('move', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMove, e));\n        registerEventHandler('moveend', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMoveEnd, e));\n        // Update any things for which we provide output bindings\n        const outputUpdateHandler = () => {\n            const zoom = this.map.getZoom();\n            if (zoom !== this.zoom) {\n                this.zoom = zoom;\n                LeafletUtil.handleEvent(this.zone, this.zoomChange, zoom);\n            }\n            const center = this.map.getCenter();\n            if (null != center || null != this.center) {\n                if (((null == center || null == this.center) && center !== this.center)\n                    || (center.lat !== this.center.lat || center.lng !== this.center.lng)) {\n                    this.center = center;\n                    LeafletUtil.handleEvent(this.zone, this.centerChange, center);\n                }\n            }\n        };\n        registerEventHandler('moveend', outputUpdateHandler);\n        registerEventHandler('zoomend', outputUpdateHandler);\n    }\n    /**\n     * Resize the map to fit it's parent container\n     */\n    doResize() {\n        // Run this outside of angular so the map events stay outside of angular\n        this.zone.runOutsideAngular(() => {\n            // Invalidate the map size to trigger it to update itself\n            if (null != this.map) {\n                this.map.invalidateSize({});\n            }\n        });\n    }\n    /**\n     * Manage a delayed resize of the component\n     */\n    delayResize() {\n        if (null != this.resizeTimer) {\n            clearTimeout(this.resizeTimer);\n        }\n        this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n    }\n    /**\n     * Set the view (center/zoom) all at once\n     * @param center The new center\n     * @param zoom The new zoom level\n     */\n    setView(center, zoom) {\n        if (null != this.map && null != center && null != zoom) {\n            this.map.setView(center, zoom, this.zoomPanOptions);\n        }\n    }\n    /**\n     * Set the map zoom level\n     * @param zoom the new zoom level for the map\n     */\n    setZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setZoom(zoom, this.zoomOptions);\n        }\n    }\n    /**\n     * Set the center of the map\n     * @param center the center point\n     */\n    setCenter(center) {\n        if (null != this.map && null != center) {\n            this.map.panTo(center, this.panOptions);\n        }\n    }\n    /**\n     * Fit the map to the bounds\n     * @param latLngBounds the boundary to set\n     */\n    setFitBounds(latLngBounds) {\n        if (null != this.map && null != latLngBounds) {\n            this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n        }\n    }\n    /**\n     * Set the map's max bounds\n     * @param latLngBounds the boundary to set\n     */\n    setMaxBounds(latLngBounds) {\n        if (null != this.map && null != latLngBounds) {\n            this.map.setMaxBounds(latLngBounds);\n        }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n    setMinZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setMinZoom(zoom);\n        }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n    setMaxZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setMaxZoom(zoom);\n        }\n    }\n}\nLeafletDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletDirective, selector: \"[leaflet]\", inputs: { fitBoundsOptions: [\"leafletFitBoundsOptions\", \"fitBoundsOptions\"], panOptions: [\"leafletPanOptions\", \"panOptions\"], zoomOptions: [\"leafletZoomOptions\", \"zoomOptions\"], zoomPanOptions: [\"leafletZoomPanOptions\", \"zoomPanOptions\"], options: [\"leafletOptions\", \"options\"], zoom: [\"leafletZoom\", \"zoom\"], center: [\"leafletCenter\", \"center\"], fitBounds: [\"leafletFitBounds\", \"fitBounds\"], maxBounds: [\"leafletMaxBounds\", \"maxBounds\"], minZoom: [\"leafletMinZoom\", \"minZoom\"], maxZoom: [\"leafletMaxZoom\", \"maxZoom\"] }, outputs: { mapReady: \"leafletMapReady\", zoomChange: \"leafletZoomChange\", centerChange: \"leafletCenterChange\", onClick: \"leafletClick\", onDoubleClick: \"leafletDoubleClick\", onMouseDown: \"leafletMouseDown\", onMouseUp: \"leafletMouseUp\", onMouseMove: \"leafletMouseMove\", onMouseOver: \"leafletMouseOver\", onMouseOut: \"leafletMouseOut\", onMapMove: \"leafletMapMove\", onMapMoveStart: \"leafletMapMoveStart\", onMapMoveEnd: \"leafletMapMoveEnd\", onMapZoom: \"leafletMapZoom\", onMapZoomStart: \"leafletMapZoomStart\", onMapZoomEnd: \"leafletMapZoomEnd\" }, host: { listeners: { \"window:resize\": \"onResize()\" } }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leaflet]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { fitBoundsOptions: [{\n                type: Input,\n                args: ['leafletFitBoundsOptions']\n            }], panOptions: [{\n                type: Input,\n                args: ['leafletPanOptions']\n            }], zoomOptions: [{\n                type: Input,\n                args: ['leafletZoomOptions']\n            }], zoomPanOptions: [{\n                type: Input,\n                args: ['leafletZoomPanOptions']\n            }], options: [{\n                type: Input,\n                args: ['leafletOptions']\n            }], mapReady: [{\n                type: Output,\n                args: ['leafletMapReady']\n            }], zoom: [{\n                type: Input,\n                args: ['leafletZoom']\n            }], zoomChange: [{\n                type: Output,\n                args: ['leafletZoomChange']\n            }], center: [{\n                type: Input,\n                args: ['leafletCenter']\n            }], centerChange: [{\n                type: Output,\n                args: ['leafletCenterChange']\n            }], fitBounds: [{\n                type: Input,\n                args: ['leafletFitBounds']\n            }], maxBounds: [{\n                type: Input,\n                args: ['leafletMaxBounds']\n            }], minZoom: [{\n                type: Input,\n                args: ['leafletMinZoom']\n            }], maxZoom: [{\n                type: Input,\n                args: ['leafletMaxZoom']\n            }], onClick: [{\n                type: Output,\n                args: ['leafletClick']\n            }], onDoubleClick: [{\n                type: Output,\n                args: ['leafletDoubleClick']\n            }], onMouseDown: [{\n                type: Output,\n                args: ['leafletMouseDown']\n            }], onMouseUp: [{\n                type: Output,\n                args: ['leafletMouseUp']\n            }], onMouseMove: [{\n                type: Output,\n                args: ['leafletMouseMove']\n            }], onMouseOver: [{\n                type: Output,\n                args: ['leafletMouseOver']\n            }], onMouseOut: [{\n                type: Output,\n                args: ['leafletMouseOut']\n            }], onMapMove: [{\n                type: Output,\n                args: ['leafletMapMove']\n            }], onMapMoveStart: [{\n                type: Output,\n                args: ['leafletMapMoveStart']\n            }], onMapMoveEnd: [{\n                type: Output,\n                args: ['leafletMapMoveEnd']\n            }], onMapZoom: [{\n                type: Output,\n                args: ['leafletMapZoom']\n            }], onMapZoomStart: [{\n                type: Output,\n                args: ['leafletMapZoomStart']\n            }], onMapZoomEnd: [{\n                type: Output,\n                args: ['leafletMapZoomEnd']\n            }], onResize: [{\n                type: HostListener,\n                args: ['window:resize', []]\n            }] } });\n\nclass LeafletDirectiveWrapper {\n    constructor(leafletDirective) {\n        this.leafletDirective = leafletDirective;\n    }\n    init() {\n        // Nothing for now\n    }\n    getMap() {\n        return this.leafletDirective.getMap();\n    }\n}\n\n/**\n * Layer directive\n *\n * This directive is used to directly control a single map layer. The purpose of this directive is to\n * be used as part of a child structural directive of the map element.\n *\n */\nclass LeafletLayerDirective {\n    constructor(leafletDirective, zone) {\n        this.zone = zone;\n        // Layer Events\n        this.onAdd = new EventEmitter();\n        this.onRemove = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n    }\n    ngOnDestroy() {\n        if (null != this.layer) {\n            // Unregister the event handlers\n            this.removeLayerEventListeners(this.layer);\n            // Remove the layer from the map\n            this.layer.remove();\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes['layer']) {\n            // Update the layer\n            const p = changes['layer'].previousValue;\n            const n = changes['layer'].currentValue;\n            this.zone.runOutsideAngular(() => {\n                if (null != p) {\n                    this.removeLayerEventListeners(p);\n                    p.remove();\n                }\n                if (null != n) {\n                    this.addLayerEventListeners(n);\n                    this.leafletDirective.getMap().addLayer(n);\n                }\n            });\n        }\n    }\n    addLayerEventListeners(l) {\n        this.onAddLayerHandler = (e) => LeafletUtil.handleEvent(this.zone, this.onAdd, e);\n        l.on('add', this.onAddLayerHandler);\n        this.onRemoveLayerHandler = (e) => LeafletUtil.handleEvent(this.zone, this.onRemove, e);\n        l.on('remove', this.onRemoveLayerHandler);\n    }\n    removeLayerEventListeners(l) {\n        l.off('add', this.onAddLayerHandler);\n        l.off('remove', this.onRemoveLayerHandler);\n    }\n}\nLeafletLayerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayerDirective, deps: [{ token: LeafletDirective }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletLayerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletLayerDirective, selector: \"[leafletLayer]\", inputs: { layer: [\"leafletLayer\", \"layer\"] }, outputs: { onAdd: \"leafletLayerAdd\", onRemove: \"leafletLayerRemove\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayerDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayer]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.NgZone }]; }, propDecorators: { layer: [{\n                type: Input,\n                args: ['leafletLayer']\n            }], onAdd: [{\n                type: Output,\n                args: ['leafletLayerAdd']\n            }], onRemove: [{\n                type: Output,\n                args: ['leafletLayerRemove']\n            }] } });\n\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\nclass LeafletLayersDirective {\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.layersDiffer = this.differs.find([]).create();\n    }\n    // Set/get the layers\n    set layers(v) {\n        this.layersValue = v;\n        // Now that we have a differ, do an immediate layer update\n        this.updateLayers();\n    }\n    get layers() {\n        return this.layersValue;\n    }\n    ngDoCheck() {\n        this.updateLayers();\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Update layers once the map is ready\n        this.updateLayers();\n    }\n    ngOnDestroy() {\n        this.layers = [];\n    }\n    /**\n     * Update the state of the layers.\n     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n     * This is important because it allows us to react to changes to the contents of the array as well\n     * as changes to the actual array instance.\n     */\n    updateLayers() {\n        const map = this.leafletDirective.getMap();\n        if (null != map && null != this.layersDiffer) {\n            const changes = this.layersDiffer.diff(this.layersValue);\n            if (null != changes) {\n                // Run outside angular to ensure layer events don't trigger change detection\n                this.zone.runOutsideAngular(() => {\n                    changes.forEachRemovedItem((c) => {\n                        map.removeLayer(c.item);\n                    });\n                    changes.forEachAddedItem((c) => {\n                        map.addLayer(c.item);\n                    });\n                });\n            }\n        }\n    }\n}\nLeafletLayersDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayersDirective, deps: [{ token: LeafletDirective }, { token: i0.IterableDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletLayersDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletLayersDirective, selector: \"[leafletLayers]\", inputs: { layers: [\"leafletLayers\", \"layers\"] }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayersDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayers]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.IterableDiffers }, { type: i0.NgZone }]; }, propDecorators: { layers: [{\n                type: Input,\n                args: ['leafletLayers']\n            }] } });\n\nclass LeafletControlLayersChanges {\n    constructor() {\n        this.layersRemoved = 0;\n        this.layersChanged = 0;\n        this.layersAdded = 0;\n    }\n    changed() {\n        return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n    }\n}\n\nclass LeafletControlLayersWrapper {\n    constructor(zone, layersControlReady) {\n        this.zone = zone;\n        this.layersControlReady = layersControlReady;\n    }\n    getLayersControl() {\n        return this.layersControl;\n    }\n    init(controlConfig, controlOptions) {\n        const baseLayers = controlConfig.baseLayers || {};\n        const overlays = controlConfig.overlays || {};\n        // Create the control outside of angular to ensure events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n            this.layersControl = control.layers(baseLayers, overlays, controlOptions);\n        });\n        this.layersControlReady.emit(this.layersControl);\n        return this.layersControl;\n    }\n    applyBaseLayerChanges(changes) {\n        let results = new LeafletControlLayersChanges();\n        if (null != this.layersControl) {\n            results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n        }\n        return results;\n    }\n    applyOverlayChanges(changes) {\n        let results = new LeafletControlLayersChanges();\n        if (null != this.layersControl) {\n            results = this.applyChanges(changes, this.layersControl.addOverlay);\n        }\n        return results;\n    }\n    applyChanges(changes, addFn) {\n        const results = new LeafletControlLayersChanges();\n        if (null != changes) {\n            // All layer management is outside angular to avoid layer events from triggering change detection\n            this.zone.runOutsideAngular(() => {\n                changes.forEachChangedItem((c) => {\n                    this.layersControl.removeLayer(c.previousValue);\n                    addFn.call(this.layersControl, c.currentValue, c.key);\n                    results.layersChanged++;\n                });\n                changes.forEachRemovedItem((c) => {\n                    this.layersControl.removeLayer(c.previousValue);\n                    results.layersRemoved++;\n                });\n                changes.forEachAddedItem((c) => {\n                    addFn.call(this.layersControl, c.currentValue, c.key);\n                    results.layersAdded++;\n                });\n            });\n        }\n        return results;\n    }\n}\n\nclass LeafletControlLayersConfig {\n    constructor() {\n        this.baseLayers = {};\n        this.overlays = {};\n    }\n}\n\n/**\n * Layers Control\n *\n * This directive is used to configure the layers control. The input accepts an object with two\n * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the last one it sees will be used.\n */\nclass LeafletLayersControlDirective {\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.layersControlReady = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n        // Generate differs\n        this.baseLayersDiffer = this.differs.find({}).create();\n        this.overlaysDiffer = this.differs.find({}).create();\n    }\n    set layersControlConfig(v) {\n        // Validation/init stuff\n        if (null == v) {\n            v = new LeafletControlLayersConfig();\n        }\n        if (null == v.baseLayers) {\n            v.baseLayers = {};\n        }\n        if (null == v.overlays) {\n            v.overlays = {};\n        }\n        // Store the value\n        this.layersControlConfigValue = v;\n        // Update the map\n        this.updateLayers();\n    }\n    get layersControlConfig() {\n        return this.layersControlConfigValue;\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Set up control outside of angular to avoid change detection when using the control\n        this.zone.runOutsideAngular(() => {\n            // Set up all the initial settings\n            this.controlLayers\n                .init({}, this.layersControlOptions)\n                .addTo(this.leafletDirective.getMap());\n        });\n        this.updateLayers();\n    }\n    ngOnDestroy() {\n        this.layersControlConfig = { baseLayers: {}, overlays: {} };\n        this.controlLayers.getLayersControl().remove();\n    }\n    ngDoCheck() {\n        this.updateLayers();\n    }\n    updateLayers() {\n        const map = this.leafletDirective.getMap();\n        const layersControl = this.controlLayers.getLayersControl();\n        if (null != map && null != layersControl) {\n            // Run the baselayers differ\n            if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n                const changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n                this.controlLayers.applyBaseLayerChanges(changes);\n            }\n            // Run the overlays differ\n            if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n                const changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n                this.controlLayers.applyOverlayChanges(changes);\n            }\n        }\n    }\n}\nLeafletLayersControlDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayersControlDirective, deps: [{ token: LeafletDirective }, { token: i0.KeyValueDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletLayersControlDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletLayersControlDirective, selector: \"[leafletLayersControl]\", inputs: { layersControlConfig: [\"leafletLayersControl\", \"layersControlConfig\"], layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"] }, outputs: { layersControlReady: \"leafletLayersControlReady\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletLayersControlDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayersControl]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.KeyValueDiffers }, { type: i0.NgZone }]; }, propDecorators: { layersControlConfig: [{\n                type: Input,\n                args: ['leafletLayersControl']\n            }], layersControlOptions: [{\n                type: Input,\n                args: ['leafletLayersControlOptions']\n            }], layersControlReady: [{\n                type: Output,\n                args: ['leafletLayersControlReady']\n            }] } });\n\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\nclass LeafletBaseLayersDirective {\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        // Output for once the layers control is ready\n        this.layersControlReady = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n        this.baseLayersDiffer = this.differs.find({}).create();\n    }\n    // Set/get baseLayers\n    set baseLayers(v) {\n        this.baseLayersValue = v;\n        this.updateBaseLayers();\n    }\n    get baseLayers() {\n        return this.baseLayersValue;\n    }\n    ngOnDestroy() {\n        this.baseLayers = {};\n        if (null != this.controlLayers.getLayersControl()) {\n            this.controlLayers.getLayersControl().remove();\n        }\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Create the control outside angular to prevent events from triggering chnage detection\n        this.zone.runOutsideAngular(() => {\n            // Initially configure the controlLayers\n            this.controlLayers\n                .init({}, this.layersControlOptions)\n                .addTo(this.leafletDirective.getMap());\n        });\n        this.updateBaseLayers();\n    }\n    ngDoCheck() {\n        this.updateBaseLayers();\n    }\n    updateBaseLayers() {\n        const map = this.leafletDirective.getMap();\n        const layersControl = this.controlLayers.getLayersControl();\n        if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n            const changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n            const results = this.controlLayers.applyBaseLayerChanges(changes);\n            if (results.changed()) {\n                this.syncBaseLayer();\n            }\n        }\n    }\n    /**\n     * Check the current base layer and change it to the new one if necessary\n     */\n    syncBaseLayer() {\n        const map = this.leafletDirective.getMap();\n        const layers = LeafletUtil.mapToArray(this.baseLayers);\n        let foundLayer;\n        // Search all the layers in the map to see if we can find them in the baselayer array\n        map.eachLayer((l) => {\n            foundLayer = layers.find((bl) => (l === bl));\n        });\n        // Did we find the layer?\n        if (null != foundLayer) {\n            // Yes - set the baselayer to the one we found\n            this.baseLayer = foundLayer;\n        }\n        else {\n            // No - set the baselayer to the first in the array and add it to the map\n            if (layers.length > 0) {\n                this.baseLayer = layers[0];\n                // Add layers outside of angular to prevent events from triggering change detection\n                this.zone.runOutsideAngular(() => {\n                    this.baseLayer.addTo(map);\n                });\n            }\n        }\n    }\n}\nLeafletBaseLayersDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletBaseLayersDirective, deps: [{ token: LeafletDirective }, { token: i0.KeyValueDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletBaseLayersDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"15.0.1\", type: LeafletBaseLayersDirective, selector: \"[leafletBaseLayers]\", inputs: { baseLayers: [\"leafletBaseLayers\", \"baseLayers\"], layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"] }, outputs: { layersControlReady: \"leafletLayersControlReady\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletBaseLayersDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletBaseLayers]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.KeyValueDiffers }, { type: i0.NgZone }]; }, propDecorators: { baseLayers: [{\n                type: Input,\n                args: ['leafletBaseLayers']\n            }], layersControlOptions: [{\n                type: Input,\n                args: ['leafletLayersControlOptions']\n            }], layersControlReady: [{\n                type: Output,\n                args: ['leafletLayersControlReady']\n            }] } });\n\nclass LeafletModule {\n}\nLeafletModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nLeafletModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletModule, declarations: [LeafletDirective,\n        LeafletLayerDirective,\n        LeafletLayersDirective,\n        LeafletLayersControlDirective,\n        LeafletBaseLayersDirective], exports: [LeafletDirective,\n        LeafletLayerDirective,\n        LeafletLayersDirective,\n        LeafletLayersControlDirective,\n        LeafletBaseLayersDirective] });\nLeafletModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.1\", ngImport: i0, type: LeafletModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [\n                        LeafletDirective,\n                        LeafletLayerDirective,\n                        LeafletLayersDirective,\n                        LeafletLayersControlDirective,\n                        LeafletBaseLayersDirective\n                    ],\n                    declarations: [\n                        LeafletDirective,\n                        LeafletLayerDirective,\n                        LeafletLayersDirective,\n                        LeafletLayersControlDirective,\n                        LeafletBaseLayersDirective\n                    ]\n                }]\n        }] });\n\nclass LeafletTileLayerDefinition {\n    constructor(type, url, options) {\n        this.type = type;\n        this.url = url;\n        this.options = options;\n    }\n    /**\n     * Creates a TileLayer from the provided definition. This is a convenience function\n     * to help with generating layers from objects.\n     *\n     * @param layerDef The layer to create\n     * @returns {TileLayer} The TileLayer that has been created\n     */\n    static createTileLayer(layerDef) {\n        let layer;\n        switch (layerDef.type) {\n            case 'xyz':\n                layer = tileLayer(layerDef.url, layerDef.options);\n                break;\n            case 'wms':\n            default:\n                layer = tileLayer.wms(layerDef.url, layerDef.options);\n                break;\n        }\n        return layer;\n    }\n    /**\n     * Creates a TileLayer for each key in the incoming map. This is a convenience function\n     * for generating an associative array of layers from an associative array of objects\n     *\n     * @param layerDefs A map of key to tile layer definition\n     * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n     */\n    static createTileLayers(layerDefs) {\n        const layers = {};\n        for (const k in layerDefs) {\n            if (layerDefs.hasOwnProperty(k)) {\n                layers[k] = (LeafletTileLayerDefinition.createTileLayer(layerDefs[k]));\n            }\n        }\n        return layers;\n    }\n    /**\n     * Create a Tile Layer from the current state of this object\n     *\n     * @returns {TileLayer} A new TileLayer\n     */\n    createTileLayer() {\n        return LeafletTileLayerDefinition.createTileLayer(this);\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LeafletBaseLayersDirective, LeafletControlLayersChanges, LeafletControlLayersConfig, LeafletControlLayersWrapper, LeafletDirective, LeafletDirectiveWrapper, LeafletLayerDirective, LeafletLayersControlDirective, LeafletLayersDirective, LeafletModule, LeafletTileLayerDefinition, LeafletUtil };\n//# sourceMappingURL=asymmetrik-ngx-leaflet.mjs.map\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}